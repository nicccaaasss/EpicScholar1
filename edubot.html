<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EpicScholar EduBot</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
<style>
/* ===========================
   ROOT + GLOBAL
=========================== */
:root {
  --grad: linear-gradient(90deg, #ff416c, #0072ff);
  --glass: rgba(255, 255, 255, 0.08);
  --border: rgba(255, 255, 255, 0.22);
  --blur: 16px;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: "Poppins", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  height: 100vh;
  display: flex;
  background: radial-gradient(circle at top left, #000, #0b0b0d);
  color: #fff;
  overflow: hidden;
}

/* ===========================
   SIDEBAR
=========================== */
.sidebar {
  width: 260px;
  min-width: 60px;
  background: var(--glass);
  border-right: 1px solid var(--border);
  backdrop-filter: blur(var(--blur));
  display: flex;
  flex-direction: column;
  transition: width .32s ease;
  border-radius: 0 20px 20px 0;
}

.sidebar.min {
  width: 60px;
}

.sidebar header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 14px;
  border-bottom: 1px solid rgba(255,255,255,0.04);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
}

.sidebar .title {
  font-weight: 700;
  font-size: 1.05rem;
  margin-left: 6px;
}

.hambtn {
  width: 40px;
  height: 40px;
  border-radius: 10px;
  border: none;
  background: var(--grad);
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  cursor: pointer;
}

.new-chat-btn {
  width: calc(100% - 16px);
  padding: 10px 8px;
  margin: 8px;
  border: none;
  border-radius: 10px;
  background: var(--grad);
  color: white;
  font-weight: 600;
  cursor: pointer;
  transition: transform .2s;
  font-size: 14px;
}

.new-chat-btn:hover {
  transform: translateY(-2px);
}

.sidebar.min .title,
.sidebar.min .new-chat-btn,
.sidebar.min .hist {
  display: none;
}

.hist {
  padding: 10px;
  overflow-y: auto;
  flex: 1;
}

.hist-section h4 {
  font-size: 12px;
  color: rgba(255,255,255,0.6);
  margin: 8px 6px;
}

.chat-entry {
  display: flex;
  align-items: center;
  padding: 10px;
  margin: 6px 4px;
  cursor: pointer;
  border-radius: 10px;
  transition: background .2s, transform .15s;
}

.chat-entry:hover {
  background: linear-gradient(90deg, rgba(255,65,108,0.12), rgba(0,198,255,0.06));
  transform: translateY(-2px);
}

/* ===========================
   MAIN AREA
=========================== */
.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.header-main {
  padding: 14px 18px;
  text-align: center;
  font-weight: 700;
  font-size: 1.25rem;
  background: var(--grad);
  border-bottom: 1px solid var(--border);
  backdrop-filter: blur(var(--blur));
  position: relative;
  left: 10%;
  width: 80%;
  border-radius: 20px;
}

.container {
  display: flex;
  flex-direction: column;
  flex: 1;
  overflow: hidden;
}

#chat {
  flex: 1;
  overflow-y: auto;
  padding: 22px;
  display: flex;
  flex-direction: column;
  gap: 14px;
  scroll-behavior: smooth;
}

#chat::-webkit-scrollbar {
  width: 8px;
}

#chat::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.08);
  border-radius: 10px;
}

/* ===========================
   MESSAGE BUBBLES
=========================== */
.message {
  max-width: 85%;
  padding: 14px 18px;
  border-radius: 12px;
  line-height: 1.6;
  position: relative;
  word-break: break-word;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.user {
  align-self: flex-end;
  background: var(--grad);
  color: #fff;
  border-radius: 18px;
  box-shadow: 0 6px 20px rgba(255,65,108,0.18);
}

.bot {
  align-self: flex-start;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.08);
  color: #fff;
  border-radius: 12px;
  backdrop-filter: blur(10px);
}

/* ===========================
   ACTION BAR (COPY / READ / STOP)
=========================== */
.actions-bar {
  position: absolute;
  right: 0;
  top: 100%;
  transform: translateY(4px);
  font-size: 11px;
  display: flex;
  align-items: center;
  gap: 6px;
  opacity: 0;
  visibility: hidden;
  transition: opacity .3s, visibility .3s;
  background: rgba(0,0,0,0.4);
  padding: 4px 8px;
  border-radius: 8px;
  backdrop-filter: blur(5px);
  z-index: 10;
}

.message.user .actions-bar {
  left: 0;
  right: auto;
}

.message:hover .actions-bar {
  opacity: 1;
  visibility: visible;
}

.action-btn {
  background: none;
  border: none;
  color: #fff;
  cursor: pointer;
  font-size: 16px;
  padding: 2px;
  transition: color .1s, transform .1s;
}

.action-btn:hover {
  color: #0072ff;
  transform: translateY(-1px);
}

.action-btn.active {
  color: #ff416c;
}

.timestamp {
  display: none;
}

/* ===========================
   IMAGES INSIDE MESSAGES
=========================== */
.message-images {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.inline-image {
  max-width: 100%;
  max-height: 300px;
  border-radius: 8px;
  object-fit: cover;
}

/* ===========================
   TYPING INDICATOR
=========================== */
.typing-container {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.06);
  border-radius: 12px;
}

.typing-container span {
  color: rgba(255,255,255,0.7);
  font-size: 14px;
}

.dot {
  width: 8px;
  height: 8px;
  background: var(--grad);
  border-radius: 50%;
  animation: bounce 1.2s infinite ease-in-out;
}

.dot:nth-child(1) {
  animation-delay: -0.32s;
}
.dot:nth-child(2) {
  animation-delay: -0.16s;
}

@keyframes bounce {
  0%, 80%, 100% { transform: translateY(0); opacity: 1; }
  40% { transform: translateY(-6px); opacity: 0.8; }
}

/* ===========================
   CURSOR (STREAMING)
=========================== */
.cursor {
  width: 8px;
  height: 8px;
  background: var(--grad);
  display: inline-block;
  border-radius: 50%;
  animation: cursor-blink 1s step-end infinite;
}

@keyframes cursor-blink {
  50% { opacity: 0; }
}

/* ===========================
   ATTACHMENTS PREVIEW
=========================== */
.attach-row {
  position: fixed;
  left: 260px;
  right: 0;
  bottom: 75px;
  padding: 10px 20px;
  display: flex; 
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
  transition: left .32s ease;
}

.sidebar.min ~ .main .attach-row {
  left: 60px;
}

.attach-thumb {
  width: 78px;
  height: 78px;
  object-fit: cover;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow: 0 6px 18px rgba(0,0,0,0.6);
}

/* ===========================
   INPUT AREA
=========================== */
.input-row {
  position: fixed;
  left: 260px;
  right: 0;
  bottom: 0;
  padding: 12px 18px;
  display: flex;
  gap: 10px;
  align-items: center;
  background: var(--glass);
  border-top: 1px solid var(--border);
  backdrop-filter: blur(var(--blur));
  transition: left .32s ease;
  border-radius: 20px 20px 0 0;
}

.sidebar.min ~ .main .input-row {
  left: 60px;
}

.input-row input[type="text"] {
  flex: 1;
  padding: 14px 18px;
  border-radius: 28px;
  border: 1px solid rgba(255,255,255,0.1);
  background: rgba(255,255,255,0.06);
  color: #fff;
  outline: none;
  transition: .2s;
}

.input-row input[type="text"]:focus {
  background: rgba(255,255,255,0.1);
  box-shadow: 0 0 0 2px rgba(0,114,255,0.4);
}

.icon-btn {
  width: 48px;
  height: 48px;
  border-radius: 16px;
  background: rgba(255,255,255,0.06);
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: .2s;
  color: #fff;
  cursor: pointer;
}

.icon-btn:hover {
  transform: translateY(-2px);
  background: rgba(255,255,255,0.1);
  box-shadow: 0 8px 22px rgba(0,0,0,0.6);
}

.icon-btn.recording {
  background: var(--grad);
  animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
  0%,100% { box-shadow: 0 0 0 0 rgba(255,65,108,0.7); }
  50% { box-shadow: 0 0 0 8px rgba(255,65,108,0.3); }
}

/* ===========================
   SCROLL TO BOTTOM BUTTON
=========================== */
.scroll-bottom {
  position: fixed;
  right: 40%;
  bottom: 100px;
  width: 46px;
  height: 46px;
  border-radius: 50%;
  background: var(--grad);
  box-shadow: 0 12px 30px rgba(0,0,0,0.6);
  display: none;
  align-items: center;
  justify-content: center;
  color: white;
  cursor: pointer;
}

.scroll-bottom.show {
  display: flex;
}

/* ===========================
   MARKDOWN TABLES
=========================== */
.markdown-table {
  border-collapse: collapse;
  margin: 12px 0;
  width: 100%;
  background: rgba(255,255,255,0.02);
  border-radius: 8px;
  overflow: hidden;
}

.markdown-table th {
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.12);
  padding: 10px 14px;
  font-weight: 600;
}

.markdown-table td {
  border: 1px solid rgba(255,255,255,0.08);
  padding: 10px 14px;
}

/* ===========================
   RESPONSIVE
=========================== */
@media (max-width:900px) {
  .sidebar {
    position: absolute;
    z-index: 40;
    transform: translateX(-100%);
  }
  .sidebar.show { transform: none; }
  .sidebar.min { transform: translateX(-100%); }

  .sidebar ~ .main .input-row,
  .sidebar ~ .main .attach-row {
    left: 0;
  }
}

/* ---------- end CSS changes ---------- */
.message .carousel {
  position: relative;
  width: 100%;
  height: 320px;
  display:flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  background: rgba(0,0,0,0.06);
  border-radius: 8px;
}
.message .carousel img {
  max-width:100%;
  max-height:100%;
  object-fit: contain; /* ensure entire video/image visible */
  display:block;
  margin:0 auto;
}
.carousel .nav-btn{
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 42px;
  height: 42px;
  border-radius: 50%;
  background: rgba(0,0,0,0.45);
  color: white;
  border: none;
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  z-index: 20;
  transition: transform .12s;
}
.carousel .nav-btn:hover{ transform: translateY(-50%) scale(1.06); }
.carousel .nav-prev{ left: 8px; }
.carousel .nav-next{ right: 8px; }

/* big floating overlay for like/heart feedback */
.big-overlay {
  position:absolute;
  left:50%; top:50%;
  transform: translate(-50%,-50%) scale(0.6);
  font-size: 96px;
  opacity: 0;
  pointer-events:none;
  text-shadow: 0 8px 32px rgba(0,0,0,0.6);
  transition: transform .45s cubic-bezier(.2,.9,.2,1), opacity .45s ease;
  z-index: 1200;
  will-change: transform, opacity;
}
.big-overlay.show {
  opacity: 0.98;
  transform: translate(-50%,-50%) scale(1.05);
}
.big-overlay.hide {
  opacity: 0;
  transform: translate(-50%,-50%) scale(1.4);
}

/* small like/love action buttons inside messages */
.action-btn.like, .action-btn.love {
  display:inline-flex; align-items:center; justify-content:center;
  gap:6px;
}
/* typewriter cursor */
.message .cursor {
  display:inline-block;
  width:8px; height:14px; background:var(--grad);
  border-radius:2px; margin-left:6px;
  animation: cursor-blink 1s step-end infinite;
}
/* ensure videos inside media are fully visible */
.media video, .message .carousel video { object-fit: contain !important; width:100% !important; height:100% !important; }
/* search focus gradient (already present but ensure specificity) */
.input-row input[type="text"]:focus, #searchBar:focus { box-shadow: 0 0 0 3px rgba(0,114,255,0.08); }
/* ...existing code... */
</style>
</head>
<body>

<div class="sidebar" id="sidebar">
Â  <header>
Â  Â  <span class="title">Chats</span>
Â  Â  <button class="hambtn" id="hambtn" title="Toggle history"><i class="fa-solid fa-bars"></i></button>
Â  </header>
Â  <button class="new-chat-btn" id="newChatBtn"><i class="fa-solid fa-plus"></i> New Chat</button>
Â  <div class="hist" id="history"></div>
</div>

<div class="main">
Â  <div class="header-main" id="headerTitle">EduBot</div>
Â  <div class="container">
Â  Â  <div id="chat"></div>
Â  Â  <div class="attach-row" id="attachRow" aria-hidden="true"></div>
Â  </div>

Â  <div class="input-row" id="inputRow">
Â  Â  <button class="icon-btn" id="voiceBtn" title="Voice"><i class="fa-solid fa-microphone"></i></button>
Â  Â  <button class="icon-btn" id="fileBtn" title="Attach"><i class="fa-solid fa-paperclip"></i></button>
Â  Â  <input type="file" id="fileInput" multiple style="display:none" />
Â  Â  <input type="text" id="userInput" placeholder="Type a message..." />
Â  Â  <button class="icon-btn" id="sendBtn" title="Send"><i class="fa-solid fa-paper-plane"></i></button>
Â  </div>
</div>

<button class="scroll-bottom" id="scrollBtn" title="Scroll to bottom"><i class="fa-solid fa-arrow-down"></i></button>

<script>
/* ---------- State ---------- */
const sidebar = document.getElementById('sidebar');
const hambtn = document.getElementById('hambtn');
const newChatBtn = document.getElementById('newChatBtn');
const headerTitle = document.getElementById('headerTitle');
const historyEl = document.getElementById('history');
const chatEl = document.getElementById('chat');
const attachRow = document.getElementById('attachRow');
const fileBtn = document.getElementById('fileBtn');
const fileInput = document.getElementById('fileInput');
const sendBtn = document.getElementById('sendBtn');
const input = document.getElementById('userInput');
const voiceBtn = document.getElementById('voiceBtn');
const scrollBtn = document.getElementById('scrollBtn');
const inputRow = document.getElementById('inputRow');

let attachedFiles = [];
let conversationHistory = [];
let savedConversations = JSON.parse(localStorage.getItem('edubot_saved')||'[]');
let currentChatId = null;
let currentChatTitle = 'New Chat';
let isStreaming = false;
let sessionStarted = Date.now();

/* ---------- Autoscroll state ---------- */
let autoScroll = true; // if true, new content scrolls to bottom
const BOTTOM_THRESHOLD = 12; // px from bottom considered "at bottom"

/* ---------- TTS (Text-to-Speech) Logic for Streaming and Read Aloud (Updated) ---------- */
const synth = window.speechSynthesis;
let currentUtterance = null;
let currentReadBtn = null; // Track which button initiated the current reading

// Function to reset the state of the read aloud button
function resetReadButton() {
Â  Â  if (currentReadBtn) {
Â  Â  Â  Â  currentReadBtn.innerHTML = '<i class="fa-solid fa-volume-up"></i>';
Â  Â  Â  Â  currentReadBtn.classList.remove('active');
Â  Â  Â  Â  currentReadBtn = null;
Â  Â  }
}

function stopSpeaking() {
Â  Â  if (synth.speaking || synth.paused) {
Â  Â  Â  Â  synth.cancel();
Â  Â  }
Â  Â  // Reset the state globally
Â  Â  resetReadButton();
Â  Â  currentUtterance = null;
}

// Global function to toggle play/pause/start
function readMessage(button) {
Â  Â  // 1. Check if speech is currently paused
Â  Â  if (synth.paused) {
Â  Â  Â  Â  synth.resume();
Â  Â  Â  Â  button.innerHTML = '<i class="fa-solid fa-pause"></i>';
Â  Â  Â  Â  button.classList.add('active');
Â  Â  Â  Â  return;
Â  Â  }

Â  Â  // 2. Check if speech is currently playing (and this button initiated it)
Â  Â  if (synth.speaking && currentUtterance && currentReadBtn === button) {
Â  Â  Â  Â  synth.pause();
Â  Â  Â  Â  button.innerHTML = '<i class="fa-solid fa-play"></i>';
Â  Â  Â  Â  button.classList.add('active'); // Keep active to show state
Â  Â  Â  Â  return;
Â  Â  }
Â  Â  
Â  Â  // 3. Stop any existing speech and prepare to start new speech
Â  Â  stopSpeaking(); 

Â  Â  const messageElement = button.closest('.message');
Â  Â  // Use textContent to get only the readable text, excluding markdown formatting
Â  Â  const messageText = messageElement.querySelector('.message-text').textContent; 
Â  Â  
Â  Â  const utterance = new SpeechSynthesisUtterance(messageText);
Â  Â  utterance.pitch = 1;
Â  Â  utterance.rate = 1.1;

Â  Â  // Setup event handlers
Â  Â  utterance.onstart = () => {
Â  Â  Â  Â  button.innerHTML = '<i class="fa-solid fa-pause"></i>';
Â  Â  Â  Â  button.classList.add('active');
Â  Â  };
Â  Â  utterance.onend = () => {
Â  Â  Â  Â  resetReadButton(); // Reset when finished
Â  Â  };

Â  Â  // Start speaking
Â  Â  currentUtterance = utterance;
Â  Â  currentReadBtn = button;
Â  Â  synth.speak(utterance);
}

/* --- Action Bar Handlers --- */
function copyToClipboard(button) {
Â  Â  const messageElement = button.closest('.message');
Â  Â  // Find the primary text content to copy, excluding timestamps/actions
Â  Â  const messageText = messageElement.querySelector('.message-text').textContent;
Â  Â  
Â  Â  if (navigator.clipboard) {
Â  Â  Â  Â  navigator.clipboard.writeText(messageText).then(() => {
Â  Â  Â  Â  Â  Â  alert('Message copied to clipboard!'); // Use alert as a simple feedback mechanism
Â  Â  Â  Â  }).catch(err => {
Â  Â  Â  Â  Â  Â  console.error('Failed to copy: ', err);
Â  Â  Â  Â  });
Â  Â  }
}


/* ---------- Session Storage ---------- */
function getSessionChat(){
Â  const key = `edubot_session_${sessionStarted}`;
Â  return JSON.parse(sessionStorage.getItem(key) || '{"history":[],"html":"","id":null,"title":"New Chat"}');
}
function saveSessionChat(){
Â  const key = `edubot_session_${sessionStarted}`;
Â  sessionStorage.setItem(key, JSON.stringify({
Â  Â  history: conversationHistory.slice(),
Â  Â  html: chatEl.innerHTML,
Â  Â  id: currentChatId,
Â  Â  title: currentChatTitle
Â  }));
}

/* ---------- New Chat ---------- */
newChatBtn.addEventListener('click', ()=>{
Â  if (chatEl.innerHTML.trim() && conversationHistory.length > 0){
Â  Â  saveCurrentChatToHistory();
Â  }
Â  clearChat();
});

function clearChat(){
Â  chatEl.innerHTML = '';
Â  conversationHistory = [];
Â  attachedFiles = [];
Â  renderAttachPreviews();
Â  currentChatId = null;
Â  currentChatTitle = 'New Chat';
Â  headerTitle.textContent = currentChatTitle;
Â  input.value = '';
Â  input.focus();
Â  sessionStarted = Date.now(); // Start a new session
Â  saveSessionChat(); // Save the new empty session state
Â  stopSpeaking(); // Stop speech on new chat
}

/* ---------- Sidebar behavior ---------- */
hambtn.addEventListener('click', () => {
Â  const isMin = sidebar.classList.toggle('min');
Â  if (window.innerWidth <= 900) sidebar.classList.toggle('show', !isMin);
});

function renderHistory(){
Â  historyEl.innerHTML = '';
Â  if (!savedConversations.length) {
Â  Â  historyEl.innerHTML = '<div style="padding:10px;color:rgba(255,255,255,0.5)">No saved chats</div>';
Â  Â  return;
Â  }
Â  const now = new Date();
Â  const groups = {Today:[], Yesterday:[], Older:[]};
Â  for (const c of savedConversations){
Â  Â  const d = new Date(c.date);
Â  Â  const diff = (now - d)/(1000*60*60*24);
Â  Â  if (diff < 1) groups.Today.push(c);
Â  Â  else if (diff < 2) groups.Yesterday.push(c);
Â  Â  else groups.Older.push(c);
Â  }
Â  for (const label of ['Today','Yesterday','Older']){
Â  Â  const list = groups[label];
Â  Â  if (!list.length) continue;
Â  Â  const h = document.createElement('div'); h.className='hist-section';
Â  Â  h.innerHTML = `<h4>${label}</h4>`;
Â  Â  historyEl.appendChild(h);
Â  Â  for (const item of list){
Â  Â  Â  const div = document.createElement('div'); div.className='chat-entry';
Â  Â  Â  div.innerHTML = `<span>${escapeHtml(item.title)}</span><span class="del" style="margin-left:16px;opacity:.7">ğŸ—‘</span>`;
Â  Â  Â  div.querySelector('.del').addEventListener('click', (ev)=>{
Â  Â  Â  Â  ev.stopPropagation();
Â  Â  Â  Â  savedConversations = savedConversations.filter(s=>s.id!==item.id);
Â  Â  Â  Â  localStorage.setItem('edubot_saved', JSON.stringify(savedConversations));
Â  Â  Â  Â  renderHistory();
Â  Â  Â  Â  if (currentChatId === item.id) {
Â  Â  Â  Â  Â  clearChat();
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  Â  div.addEventListener('click', ()=> {
Â  Â  Â  Â  if (chatEl.innerHTML.trim() && conversationHistory.length > 0) {
Â  Â  Â  Â  Â  saveCurrentChatToHistory();
Â  Â  Â  Â  }
Â  Â  Â  Â  chatEl.innerHTML = item.html;
Â  Â  Â  Â  conversationHistory = item.history || [];
Â  Â  Â  Â  currentChatId = item.id;
Â  Â  Â  Â  currentChatTitle = item.title;
Â  Â  Â  Â  headerTitle.textContent = currentChatTitle;
Â  Â  Â  Â  chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  Â  Â  attachedFiles = [];
Â  Â  Â  Â  renderAttachPreviews();
Â  Â  Â  Â  saveSessionChat();
Â  Â  Â  Â  stopSpeaking();
Â  Â  Â  });
Â  Â  Â  historyEl.appendChild(div);
Â  Â  }
Â  }
}
renderHistory();

/* ---------- Helpers ---------- */
function escapeHtml(unsafe){
Â  return unsafe
Â  Â  .replace(/&/g,"&amp;")
Â  Â  .replace(/</g,"&lt;")
Â  Â  .replace(/>/g,"&gt;")
Â  Â  .replace(/"/g,"&quot;")
Â  Â  .replace(/'/g,"&#039;");
}

/* ---------- Improved Markdown Formatter (supports headings, lists, code blocks, inline code, tables, bold/italic) ---------- */
function formatMarkdownToHtml(rawText){
Â  if (!rawText) return '';
Â  // First escape to avoid XSS
Â  const text = escapeHtml(rawText);

Â  // handle code fences first (``` ... ```)
Â  const codeBlocks = [];
Â  let placeholderIndex = 0;
Â  const codeFenceRe = /```([\s\S]*?)```/g;
Â  const withPlaceholders = text.replace(codeFenceRe, (m, inner) => {
Â  Â  const token = `@@CODE_BLOCK_${placeholderIndex}@@`;
Â  Â  codeBlocks.push(inner);
Â  Â  placeholderIndex++;
Â  Â  return token;
Â  });

Â  const lines = withPlaceholders.split(/\r?\n/);
Â  let out = '';
Â  let inList = false;
Â  let listType = null; // 'ul' or 'ol'
Â  let inTable = false;
Â  let tableRows = [];

Â  for (let i = 0; i < lines.length; i++){
Â  Â  let line = lines[i];

Â  Â  // Table detection: simple pipe tables
Â  Â  if (/^\s*\|.*\|\s*$/.test(line)){
Â  Â  Â  inTable = true;
Â  Â  Â  tableRows.push(line.trim());
Â  Â  Â  continue;
Â  Â  } else if (inTable) {
Â  Â  Â  // flush table
Â  Â  Â  out += renderTableFromRows(tableRows);
Â  Â  Â  tableRows = [];
Â  Â  Â  inTable = false;
Â  Â  }

Â  Â  // Headings
Â  Â  const hMatch = line.match(/^\s*(#{1,6})\s+(.*)$/);
Â  Â  if (hMatch){
Â  Â  Â  // close list if open
Â  Â  Â  if (inList){
Â  Â  Â  Â  out += closeList(listType);
Â  Â  Â  Â  inList = false; listType = null;
Â  Â  Â  }
Â  Â  Â  const level = hMatch[1].length;
Â  Â  Â  out += `<h${level}>${inlineFormat(hMatch[2])}</h${level}>`;
Â  Â  Â  continue;
Â  Â  }

Â  Â  // Ordered list
Â  Â  const olMatch = line.match(/^\s*\d+\.\s+(.*)$/);
Â  Â  // Unordered list
Â  Â  const ulMatch = line.match(/^\s*[-*+]\s+(.*)$/);

Â  Â  if (ulMatch || olMatch){
Â  Â  Â  const thisType = ulMatch ? 'ul' : 'ol';
Â  Â  Â  const itemText = (ulMatch ? ulMatch[1] : olMatch[1]).trim();

Â  Â  Â  if (!inList){
Â  Â  Â  Â  // open list
Â  Â  Â  Â  out += `<${thisType}>`;
Â  Â  Â  Â  inList = true;
Â  Â  Â  Â  listType = thisType;
Â  Â  Â  } else if (listType !== thisType){
Â  Â  Â  Â  // close previous, open new
Â  Â  Â  Â  out += closeList(listType);
Â  Â  Â  Â  out += `<${thisType}>`;
Â  Â  Â  Â  listType = thisType;
Â  Â  Â  }
Â  Â  Â  out += `<li>${inlineFormat(itemText)}</li>`;
Â  Â  Â  continue;
Â  Â  } else {
Â  Â  Â  if (inList){
Â  Â  Â  Â  out += closeList(listType);
Â  Â  Â  Â  inList = false; listType = null;
Â  Â  Â  }
Â  Â  }

Â  Â  // Blank line -> paragraph break
Â  Â  if (line.trim() === ''){
Â  Â  Â  out += '<br/>';
Â  Â  Â  continue;
Â  Â  }

Â  Â  // Inline formatting and simple block paragraphs
Â  Â  out += `<p style="margin:0;padding:0;">${inlineFormat(line)}</p>`;
Â  }

Â  if (inList){
Â  Â  out += closeList(listType);
Â  }
Â  if (inTable && tableRows.length){
Â  Â  out += renderTableFromRows(tableRows);
Â  }

Â  // Put back code blocks
Â  let final = out;
Â  for (let j = 0; j < codeBlocks.length; j++){
Â  Â  const token = `@@CODE_BLOCK_${j}@@`;
Â  Â  const raw = codeBlocks[j];
Â  Â  // Keep inner as escaped text but wrap in pre/code
Â  Â  final = final.split(token).join(`<pre class="code-block" style="background:rgba(0,0,0,0.45);padding:8px;border-radius:6px;overflow:auto"><code>${raw.replace(/</g,'&lt;')}</code></pre>`);
Â  }

Â  // Clean multiple <br/>
Â  final = final.replace(/(<br\/>\s*){2,}/g,'<br/>');

Â  return final;
}

// helper: inline formatting of bold, italic, inline code, emoji shortcuts
function inlineFormat(s){
Â  if (!s) return '';
Â  // inline code `code`
Â  s = s.replace(/`([^`]+)`/g, '<code style="background:rgba(255,255,255,0.06);padding:2px 6px;border-radius:4px;font-family:monospace;font-size:0.95em">$1</code>');
Â  // bold **text**
Â  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
Â  // italic *text*
Â  s = s.replace(/(^|[^*])\*(?!\*)(.+?)\*(?!\*)/g, (m, p1, p2) => `${p1}<em>${p2}</em>`);
Â  // emoji shortcuts like :smile:
Â  s = s.replace(/:([a-z0-9_+-]+):/gi, (m, name) => {
Â  Â  const map = {smile:'ğŸ˜Š', thumbs_up:'ğŸ‘', heart:'â¤ï¸', fire:'ğŸ”¥', star:'â­'};
Â  Â  return map[name] || m;
Â  });
Â  // auto-link URLs (simple)
Â  s = s.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
Â  return s;
}

function closeList(type){
Â  return `</${type}>`;
}

function renderTableFromRows(rows){
Â  // rows are strings like "| a | b |"
Â  if (!rows.length) return '';
Â  // sanitize and parse
Â  const parsed = rows.map(r => r.replace(/^\||\|$/g,'').split('|').map(c => c.trim()));
Â  // If only one row â€” treat as normal line(s)
Â  if (parsed.length < 2) {
Â  Â  return parsed.map(r => r.join(' | ')).map(cell => `<p>${inlineFormat(cell)}</p>`).join('');
Â  }
Â  const header = parsed[0];
Â  let html = '<table class="markdown-table"><thead><tr>';
Â  header.forEach(h=> html += `<th>${inlineFormat(h)}</th>`);
Â  html += '</tr></thead><tbody>';
Â  for (let i = 1; i < parsed.length; i++){
Â  Â  const row = parsed[i];
Â  Â  // skip divider rows like ---|--- 
Â  Â  if (row.every(c => /^-+$/.test(c))) continue;
Â  Â  html += '<tr>';
Â  Â  row.forEach(c=> html += `<td>${inlineFormat(c)}</td>`);
Â  Â  html += '</tr>';
Â  }
Â  html += '</tbody></table>';
Â  return html;
}

/* ---------- Message rendering ---------- */
function appendMessage(text, sender, images = []) {
Â  Â  const timestamp = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});

Â  Â  const div = document.createElement('div');
Â  Â  div.className=`message ${sender}`;

Â  Â  // Images
Â  Â  if (images && images.length > 0){
Â  Â  Â  Â  const imgContainer = document.createElement('div');
Â  Â  Â  Â  imgContainer.className = 'message-images';
Â  Â  Â  Â  images.forEach(imgSrc => {
Â  Â  Â  Â  Â  Â  const img = document.createElement('img');
Â  Â  Â  Â  Â  Â  img.src = imgSrc;
Â  Â  Â  Â  Â  Â  img.className = 'inline-image';
Â  Â  Â  Â  Â  Â  imgContainer.appendChild(img);
Â  Â  Â  Â  });
Â  Â  Â  Â  div.appendChild(imgContainer);
Â  Â  }

Â  Â  const content = document.createElement('div');
Â  Â  content.className = 'message-text';
Â  Â  content.innerHTML = formatMarkdownToHtml(text); // Initial content if not streaming
Â  Â  div.appendChild(content);

Â  Â  // Actions Bar
Â  Â  const actionsBar = document.createElement('div');
Â  Â  actionsBar.className = 'actions-bar';
Â  Â  
Â  Â  const timestampSpan = document.createElement('span');
Â  Â  timestampSpan.className = 'timestamp-text';
Â  Â  timestampSpan.textContent = timestamp;
Â  Â  actionsBar.appendChild(timestampSpan);

Â  Â  const copyBtn = document.createElement('button');
Â  Â  copyBtn.className = 'action-btn';
Â  Â  copyBtn.innerHTML = '<i class="fa-solid fa-copy"></i>';
Â  Â  copyBtn.onclick = () => copyToClipboard(copyBtn);
Â  Â  copyBtn.title = 'Copy message';
Â  Â  actionsBar.appendChild(copyBtn);

Â  Â  const readBtn = document.createElement('button');
Â  Â  readBtn.className = 'action-btn';
Â  Â  readBtn.innerHTML = '<i class="fa-solid fa-volume-up"></i>';
Â  Â  readBtn.onclick = () => readMessage(readBtn);
Â  Â  readBtn.title = 'Read aloud';
Â  Â  actionsBar.appendChild(readBtn);

Â  Â  div.appendChild(actionsBar);

Â  Â  chatEl.appendChild(div);
Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  return content; // Return the text container for streaming updates
}


function appendUserMessage(text, images) {
Â  Â  appendMessage(text, 'user', images);
}


/* ---------- Typing indicator (Updated) ---------- */
function showTypingIndicator(){
Â  Â  const el = document.createElement('div');
Â  Â  el.className='message bot';
Â  Â  el.dataset.typing='1';
Â  Â  el.innerHTML = `
Â  Â  Â  Â  <div class="typing-container">
Â  Â  Â  Â  Â  Â  <div class="dot"></div>
Â  Â  Â  Â  Â  Â  <div class="dot"></div>
Â  Â  Â  Â  Â  Â  <div class="dot"></div>
Â  Â  Â  Â  Â  Â  <span>EduBot is thinking</span>
Â  Â  Â  Â  </div>
Â  Â  `;
Â  Â  chatEl.appendChild(el);
Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  return el;
}
function removeTypingIndicator(el){ if(el && el.parentNode) el.parentNode.removeChild(el); }

/* ---------- Streaming bot message: real-time formatted + autoscroll handling (Updated with TTS) ---------- */
function appendBotMessageStream(text, images = []){
Â  Â  stopSpeaking(); // Stop any previous speech synthesis immediately

Â  Â  const timestamp = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
Â  Â  
Â  Â  const div = document.createElement('div');
Â  Â  div.className='message bot';

Â  Â  // Add images first if any
Â  Â  if (images.length > 0){
Â  Â  Â  Â  const imgContainer = document.createElement('div');
Â  Â  Â  Â  imgContainer.className = 'message-images';
Â  Â  Â  Â  images.forEach(img => {
Â  Â  Â  Â  Â  Â  const imgEl = document.createElement('img');
Â  Â  Â  Â  Â  Â  imgEl.src = img;
Â  Â  Â  Â  Â  Â  imgEl.className = 'inline-image';
Â  Â  Â  Â  Â  Â  imgContainer.appendChild(imgEl);
Â  Â  Â  Â  });
Â  Â  Â  Â  div.appendChild(imgContainer);
Â  Â  }

Â  Â  const textContainer = document.createElement('div');
Â  Â  textContainer.className = 'message-text';
Â  Â  div.appendChild(textContainer);

Â  Â  // Actions Bar (initially empty, filled on finalization)
Â  Â  const actionsBar = document.createElement('div');
Â  Â  actionsBar.className = 'actions-bar';
Â  Â  div.appendChild(actionsBar);


Â  Â  chatEl.appendChild(div);
Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;

Â  Â  // Split by words/punctuation chunks for better TTS/streaming
Â  Â  const tokens = text.match(/[^.!?]+[.!?]|\s+|\S+/g) || [text]; 
Â  Â  let idx = 0;
Â  Â  let currentText = '';
Â  Â  isStreaming = true;
Â  Â  sendBtn.innerHTML = '<i class="fa-solid fa-square"></i>';

Â  Â  const pump = async () => {
Â  Â  Â  Â  if (!isStreaming) {
Â  Â  Â  Â  Â  Â  finalizeStream();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  if (idx >= tokens.length) {
Â  Â  Â  Â  Â  Â  finalizeStream();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }

Â  Â  Â  Â  const chunk = tokens[idx];
Â  Â  Â  Â  currentText += chunk;
Â  Â  Â  Â  idx++;
Â  Â  Â  Â  
Â  Â  Â  Â  // NO AUTOMATIC READ ALOUD HERE

Â  Â  Â  Â  // REAL-TIME formatting and CURSOR
Â  Â  Â  Â  const formatted = formatMarkdownToHtml(currentText);
Â  Â  Â  Â  textContainer.innerHTML = formatted + `<span class="cursor"></span>`;

Â  Â  Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;

Â  Â  Â  Â  const delay = 35;
Â  Â  Â  Â  await new Promise(r => setTimeout(r, delay));
Â  Â  Â  Â  pump();
Â  Â  };

Â  Â  const finalizeStream = () => {
Â  Â  Â  Â  // Clean up cursor
Â  Â  Â  Â  textContainer.innerHTML = formatMarkdownToHtml(currentText);

Â  Â  Â  Â  // Add final actions bar content
Â  Â  Â  Â  actionsBar.innerHTML = `
Â  Â  Â  Â  Â  Â  <span class="timestamp-text">${timestamp}</span>
Â  Â  Â  Â  Â  Â  <button class="action-btn" onclick="copyToClipboard(this)" title="Copy message"><i class="fa-solid fa-copy"></i></button>
Â  Â  Â  Â  Â  Â  <button class="action-btn" onclick="readMessage(this)" title="Read aloud"><i class="fa-solid fa-volume-up"></i></button>
Â  Â  Â  Â  `;
Â  Â  Â  Â  
Â  Â  Â  Â  isStreaming = false;
Â  Â  Â  Â  sendBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
Â  Â  Â  Â  saveSessionChat();
Â  Â  Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  };

Â  Â  pump();
}

/* ---------- Error message ---------- */
function appendBotMessageError(msg){
Â  Â  stopSpeaking();
Â  Â  const timestamp = new Date().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});

Â  Â  const div = document.createElement('div');
Â  Â  div.className='message bot';
Â  Â  div.innerHTML = escapeHtml(msg);

Â  Â  const actionsBar = document.createElement('div');
Â  Â  actionsBar.className = 'actions-bar';
Â  Â  actionsBar.innerHTML = `<span class="timestamp-text">${timestamp} (Error)</span>`;

Â  Â  div.appendChild(actionsBar);
Â  Â  chatEl.appendChild(div);

Â  Â  if (autoScroll) chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  isStreaming = false;
Â  Â  sendBtn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
}

/* ---------- File attach UI ---------- */
fileBtn.addEventListener('click', ()=>fileInput.click());
fileInput.addEventListener('change', e=>{
Â  attachedFiles = [...e.target.files];
Â  renderAttachPreviews();
});

function renderAttachPreviews(){
Â  attachRow.innerHTML = '';
Â  if (!attachedFiles.length) { attachRow.setAttribute('aria-hidden','true'); return; }
Â  attachRow.setAttribute('aria-hidden','false');
Â  attachedFiles.forEach((f, idx)=>{
Â  Â  const el = document.createElement('div');
Â  Â  if (f.type.startsWith('image/')){
Â  Â  Â  const img = document.createElement('img'); img.src = URL.createObjectURL(f); img.className='attach-thumb';
Â  Â  Â  el.appendChild(img);
Â  Â  } else {
Â  Â  Â  const d = document.createElement('div'); d.textContent = f.name;
Â  Â  Â  d.style.cssText = 'padding:8px 12px;background:rgba(255,255,255,0.05);border-radius:8px;font-size:12px;max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap';
Â  Â  Â  el.appendChild(d);
Â  Â  }
Â  Â  const rm = document.createElement('button'); rm.className='icon-btn'; rm.style.width='30px'; rm.style.height='30px'; rm.style.marginLeft='8px';
Â  Â  rm.innerHTML = 'âœ•'; rm.title='Remove';
Â  Â  rm.addEventListener('click', (ev)=>{ ev.stopPropagation(); attachedFiles.splice(idx,1); renderAttachPreviews(); });
Â  Â  el.style.display='flex'; el.style.alignItems='center';
Â  Â  el.appendChild(rm);
Â  Â  attachRow.appendChild(el);
Â  });
}

/* ---------- AI Chat Name Generation (from entire conversation) ---------- */
async function generateChatName(conversationContext){
Â  try{
Â  Â  const messages = conversationContext.slice(-4).map(m => `${m.role === 'user' ? 'User' : 'Bot'}: ${m.parts[0]?.text || ''}`).join('\n');
Â  Â  const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyC8AS_0u1toc_GN530woL4HjmpbwtvBro8`, {
Â  Â  Â  method:'POST',
Â  Â  Â  headers:{'Content-Type':'application/json'},
Â  Â  Â  body:JSON.stringify({
Â  Â  Â  Â  contents:[{
Â  Â  Â  Â  Â  role:'user',
Â  Â  Â  Â  Â  parts:[{text:`Based on this conversation topic, generate a short, concise title (max 6 words). Return ONLY the title:\n\n${messages}`}]
Â  Â  Â  Â  }]
Â  Â  Â  })
Â  Â  });
Â  Â  const data = await res.json();
Â  Â  const title = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || 'New Chat';
Â  Â  return title.substring(0, 50);
Â  }catch(err){
Â  Â  return 'New Chat';
Â  }
}

/* ---------- Send & Stream ---------- */
sendBtn.addEventListener('click', ()=> {
Â  if (isStreaming) {
Â  Â  // stop streaming (pump will check isStreaming and finalize)
Â  Â  isStreaming = false;
Â  Â  stopSpeaking();
Â  Â  return;
Â  }
Â  startSend();
});
input.addEventListener('keypress', e=> { if (e.key==='Enter' && !isStreaming) startSend(); });

async function startSend(){
Â  const text = input.value.trim();
Â  if (!text && attachedFiles.length === 0) return;

Â  input.value=''; // Clear input immediately
Â  
Â  const parts = [{ text }];
Â  const userImageUrls = []; // To store data URLs for the UI

Â  for (const f of attachedFiles){
Â  Â  if (f.type.startsWith('image/')){
Â  Â  Â  const base64Url = await toBase64(f);
Â  Â  Â  userImageUrls.push(base64Url); // For UI
Â  Â  Â  const base64Data = base64Url.split(',')[1];
Â  Â  Â  parts.push({ inlineData: { mimeType: f.type, data: base64Data } }); // For API
Â  Â  } else {
Â  Â  Â  parts.push({ text: `[file:${f.name}]` });
Â  Â  }
Â  }

Â  appendUserMessage(text, userImageUrls); // Use the updated appendMessage
Â  attachedFiles = [];
Â  renderAttachPreviews();

Â  conversationHistory.push({ role:'user', parts: parts });

Â  const typingEl = showTypingIndicator();
Â  isStreaming = true;
Â  sendBtn.innerHTML = '<i class="fa-solid fa-square"></i>';

Â  try {
Â  Â  const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyC8AS_0u1toc_GN530woL4HjmpbwtvBro8`, {
Â  Â  Â  method:'POST',
Â  Â  Â  headers:{'Content-Type':'application/json'},
Â  Â  Â  body:JSON.stringify({contents: conversationHistory.slice(-6)})
Â  Â  });

Â  Â  const data = await res.json();
Â  Â  const reply = data?.candidates?.[0]?.content?.parts?.[0]?.text || "Sorry, I couldn't understand that.";

Â  Â  removeTypingIndicator(typingEl);
Â  Â  appendBotMessageStream(reply, []);
Â  Â  conversationHistory.push({role:'model',parts:[{text:reply}]});

Â  Â  // Generate chat name based on conversation topic
Â  Â  if (currentChatTitle === 'New Chat' && !currentChatId && conversationHistory.length >= 2){
Â  Â  Â  const name = await generateChatName(conversationHistory);
Â  Â  Â  currentChatTitle = name;
Â  Â  Â  headerTitle.textContent = currentChatTitle;
Â  Â  Â  saveSessionChat();
Â  Â  } else if (conversationHistory.length > 6 && conversationHistory.length % 4 === 0){
Â  Â  Â  const name = await generateChatName(conversationHistory);
Â  Â  Â  if (name !== 'New Chat') currentChatTitle = name;
Â  Â  Â  headerTitle.textContent = currentChatTitle;
Â  Â  Â  saveSessionChat();
Â  Â  }

Â  }
Â  catch(err){
Â  Â  removeTypingIndicator(typingEl);
Â  Â  appendBotMessageError('Error: ' + err.message);
Â  }
}

/* ---------- Save & Restore chats ---------- */
function saveCurrentChatToHistory(){
Â  if (!conversationHistory.length) return;

Â  const record = {
Â  Â  id: currentChatId,
Â  Â  title: currentChatTitle || 'New Chat',
Â  Â  date: new Date().toISOString(),
Â  Â  html: chatEl.innerHTML,
Â  Â  history: conversationHistory.slice()
Â  };

Â  if (currentChatId) {
Â  Â  const idx = savedConversations.findIndex(c => c.id === currentChatId);
Â  Â  if (idx > -1) {
Â  Â  Â  savedConversations.splice(idx, 1);
Â  Â  }
Â  Â  savedConversations.unshift(record);
Â  } else {
Â  Â  record.id = Date.now().toString(36) + Math.random().toString(36).slice(2,6);
Â  Â  currentChatId = record.id;
Â  Â  savedConversations.unshift(record);
Â  }

Â  if (savedConversations.length > 50) savedConversations.pop();
Â  localStorage.setItem('edubot_saved', JSON.stringify(savedConversations));
Â  renderHistory();
}

/* ---------- Load session on page load ---------- */
window.addEventListener('load', ()=> {
Â  renderHistory();
Â  const session = getSessionChat();
Â  if (session.history.length > 0){
Â  Â  conversationHistory = session.history;
Â  Â  chatEl.innerHTML = session.html;
Â  Â  chatEl.scrollTop = chatEl.scrollHeight;
Â  Â  currentChatId = session.id;
Â  Â  currentChatTitle = session.title || 'New Chat';
Â  Â  headerTitle.textContent = currentChatTitle;
Â  }
Â  input.focus();
});

/* ---------- Voice ---------- */
let rec=null, recOn=false;
if ('webkitSpeechRecognition' in window) {
Â  rec = new webkitSpeechRecognition();
Â  rec.lang = 'en-US';
Â  rec.onstart = ()=> {
Â  Â  voiceBtn.classList.add('recording');
Â  };
Â  rec.onend = ()=> {
Â  Â  voiceBtn.classList.remove('recording');
Â  Â  recOn = false;
Â  };
Â  rec.onresult = e => { input.value = e.results[0][0].transcript; };
}
voiceBtn.addEventListener('click', ()=>{
Â  if (!rec){ alert('Voice not supported by this browser'); return; }
Â  if (!recOn){ rec.start(); recOn=true; }
Â  else { rec.stop(); }
});

/* ---------- Scroll / Autoscroll behavior ---------- */
// Replace previous scroll handler: decide autoscroll vs manual
chatEl.addEventListener('scroll', () => {
Â  const distanceFromBottom = chatEl.scrollHeight - (chatEl.scrollTop + chatEl.clientHeight);
Â  if (distanceFromBottom > BOTTOM_THRESHOLD) {
Â  Â  autoScroll = false; // user scrolled up
Â  } else {
Â  Â  autoScroll = true; // near bottom, re-enable autoscroll
Â  }

Â  // show manual scroll-to-bottom button if user isn't at bottom
Â  if (distanceFromBottom > 220) scrollBtn.classList.add('show');
Â  else scrollBtn.classList.remove('show');
});
scrollBtn.addEventListener('click', ()=> {
Â  chatEl.scrollTo({top:chatEl.scrollHeight, behavior:'smooth'});
Â  // after smooth scroll finishes, ensure autoScroll true (approx)
Â  setTimeout(()=> { autoScroll = true; scrollBtn.classList.remove('show'); }, 300);
});

/* ---------- Utilities ---------- */
function toBase64(file){
Â  return new Promise((res,rej)=>{
Â  Â  const r=new FileReader();
Â  Â  r.onload=()=>{ res(r.result); }
Â  Â  r.onerror=rej;
Â  Â  r.readAsDataURL(file);
Â  });
}

/* ---------- Save session before leaving ---------- */
window.addEventListener('beforeunload', ()=>{
Â  if (conversationHistory.length > 0){
Â  Â  saveCurrentChatToHistory();
Â  }
Â  // Ensure speech is cancelled before closing/reloading
Â  stopSpeaking();
});
</script>
</body>
</html>
